(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{472:function(n,e,t){"use strict";t.r(e);var a=t(46),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h4",{attrs:{id:"工具类方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工具类方法"}},[n._v("#")]),n._v(" 工具类方法")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("1.axios 工具")])]),n._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[n._v("图片加载工具")])])])]),n._v(" "),t("p",[t("a",{attrs:{href:"#jump"}},[n._v("XXXX")]),n._v("\n阿斯顿发撒的\ns")]),n._v(" "),t("p",[n._v("ss")]),n._v(" "),t("p",[n._v("撒发生")]),n._v(" "),t("p",[n._v("sfa")]),n._v(" "),t("p",[n._v("asf")]),n._v(" "),t("p",[n._v("sfa")]),n._v(" "),t("p",[n._v("是")]),n._v(" "),t("p",[n._v("sf"),t("br"),n._v("\n阿三"),t("br"),n._v("\n阿"),t("br"),n._v("\n阿三")]),n._v(" "),t("p",[n._v("#前端模块化历史")]),n._v(" "),t("h2",{attrs:{id:"_1-为什么要模块化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么要模块化"}},[n._v("#")]),n._v(" 1.为什么要模块化")]),n._v(" "),t("ul",[t("li",[n._v("1.抽离公共代码")]),n._v(" "),t("li",[n._v("2.隔离作用域、避免变量冲突")])]),n._v(" "),t("h2",{attrs:{id:"_2-前端发展历史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-前端发展历史"}},[n._v("#")]),n._v(" 2.前端发展历史")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("web1.0 时代")]),n._v(" "),t("ul",[t("li",[n._v("网页是“只读的”，用户只能搜索信息，浏览信息。")])])]),n._v(" "),t("li",[t("p",[n._v("web2.0 时代")]),n._v(" "),t("ul",[t("li",[n._v("主要特征是有了交互的概念，不仅仅局限于浏览，可以自己创建内容并上传")]),n._v(" "),t("li",[n._v("JavaScript作为嵌入式的脚本语言诞生")])])]),n._v(" "),t("li",[t("p",[n._v("web2.0 出现的问题\n+ Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀,需要在前端也引入模块化概念")])])]),n._v(" "),t("h2",{attrs:{id:"_3-解决方案的演变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-解决方案的演变"}},[n._v("#")]),n._v(" 3.解决方案的演变")]),n._v(" "),t("h3",{attrs:{id:"针对以上问题-前端开发者开始探索自己的解决办法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#针对以上问题-前端开发者开始探索自己的解决办法"}},[n._v("#")]),n._v(" 针对以上问题，前端开发者开始探索自己的解决办法")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("IIFE")]),n._v(" "),t("p",[n._v("最先开始我们每一个功能都写一个function;就像这样")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fn1(){\n   statement\n}\n\nfunction fn2(){\n   statement\n}\n\n")])])]),t("p",[n._v("这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系，为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中\n像这样写法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("  var myModule = {\n      var1: 1,\n  \n      var2: 2,\n  \n      fn1: function(){\n  \n      },\n  \n      fn2: function(){\n  \n      }\n  }\n")])])]),t("p",[n._v("看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员;比如myModule.var1 = 100;这样就会产生安全问题\n所以IIFE就出来了\nIIFE: Immediately Invoked Function Expression，意为立即调用的函数表达式，也就是说，声明函数的同时立即调用这个函数。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('var myModule = (function module(){\n      var someThing = "123";\n      var otherThing = [1,2,3];\n        \n      function doSomeThing(){\n        console.log(someThing);\n      }\n        \n      function doOtherThing(){\n        console.log(otherThing);\n      }\n        \n      return {\n        doSomeThing:doSomeThing,\n        doOtherThing:doOtherThing\n      }\n  })();\n\nmyModule.doSomeThing();\nmyModule.doOtherThing();\n\n')])])])]),n._v(" "),t("li",[t("p",[n._v("common.js\n一开始大家都认为JS是辣鸡，没什么用，官方定义的API只能构建基于浏览器的应用程序，CommonJS就按耐不住了\n，CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。官方网址：http://www.commonjs.org/\n它的终极目标是提供一个类似Python，Ruby和Java标准库。\n这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。\nnode.js 就是应用common.js开发的项目，2009年诞生。在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；\n但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现。\n列举一个最简单的 common.js  模块引用 看看common.js 如何工作的")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("A.js\nfunction speak(name){\nconsole.log('speak name')\n}\nmodule.exports = speak\n\nB.js\nrequire('./A.js')\nspeak('common.js')\n// common.js\n")])])]),t("p",[n._v("我们来手写一个common.js 的规范")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" (function (exports, require, module, __filename, __dirname) {\n     module.exports = function () {\n         console.log(__dirname);\n     }\n })\n")])])]),t("p",[n._v("node 做的就是调用此方法，将 exports, require, module, __filename, __dirname 传入进去\n"),t("a",{attrs:{href:"#jump2"}},[n._v("XXXX")]),n._v("\n我百度了 require 的 方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const fs = require('fs');\nconst path = require('path');\nconst vm = require('vm'); // 虚拟机，提供沙箱环境\nconst wrapper = [\n    '(function(exports, module, require){',\n    '})'\n]\nfunction Module(absPath) {\n    this.id = absPath; // 存储当前路径\n    this.exports = {};\n}\nModule.prototype.load = function() {\n    let script = fs.readFileSync(this.id, 'utf8');\n    let fnStr = wrapper[0] + script + wrapper[1];\n    let fn = vm.runInThisContext(fnStr); // 沙箱执行当前函数\n    fn(this.exports, this, req); // 让拼出的函数执行\n}\n\nfunction req(file ) {\n   let absPath = path.resolve(__dirname, file); // 1. 获取文件路径\n   let module = new Module(absPath); // 2. 创建一个模块\n   module.load(); // 3. 加载方法\n   return module.exports;\n}\nlet a = req('./a.js')\n")])])])])]),n._v(" "),t("p",[n._v("阿三"),t("br"),n._v("\n阿"),t("br"),n._v("\n阿\na")]),n._v(" "),t("p",[n._v("阿三\n阿")])])}),[],!1,null,null,null);e.default=s.exports}}]);